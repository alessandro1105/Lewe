package com.example.servicetest;

import java.util.HashMap;

public abstract class Jack {
	
	private static final long TIMER = 1000; //tempo del timer in ms
	
	
	private static final String MESSAGE_TYPE = "message_type"; //campo dentro messageJackData che contine il tipo di mex
	private static final String MESSAGE_DATA = "message_data"; //campo contente dati nel messaggio tipo dati 
	
	private static final String MESSAGE_ID = "id";
		
	private static final String MESSAGE_TYPE_ACK = "ack"; //messaggio ack per qualcosa inviato
	private static final String MESSAGE_TYPE_DATA = "values"; //messaggio normale contenente dati
		
	private static final String MESSAGE_BOOLEAN_TRUE = "t"; //simobolo true in booleano nel mex
	private static final String MESSAGE_BOOLEAN_FALSE = "f"; //simbolo false nel mex
	
	
	
	JTrasmissionMethod mmJTM; //contiene il metodo di trasmissione da usare e deve rispettare l'interfaccia
	
	
	boolean startThread;
	
	GetMessageThread getMessageThread; //thread get message
	
	SendMessageThread sendMessageThread; //thread send message
	
	
	
	HashMap<Long, String> sendMessageBuffer;
	HashMap<Long, Long> sendMessageTimer;
	
	HashMap<Long, String> sendAckBuffer;
	
	public Jack(JTrasmissionMethod mmJTM) {
		
		this.mmJTM = mmJTM;
		
		startThread = false; //thread spenti
		
		
		sendMessageBuffer = new HashMap<Long, String>(); //buffer messaggi
		sendMessageTimer = new HashMap<Long, Long>(); //timer per invio messaggi
		
		sendAckBuffer = new HashMap<Long, String>(); //buffer ack
		
		
		sendMessageThread = new SendMessageThread(); //thread invio messaggi
		
		getMessageThread = new GetMessageThread(); //creo thread per get message e lo avvio
		
	}
	
	public void start() { //start thread
		startThread = true;
	}
	
	public void stop() { //stop thread
		startThread = false;
	}
	
	private synchronized void execute(String message) { //corpo centreale della classe e decide cosa deve fare
		
		if (validate(message)) {
			
			JData messageJData = getJDataMessage(message); 
			
			if (messageJData.get(MESSAGE_TYPE) == MESSAGE_TYPE_DATA) {
				
				sendAck(messageJData);
				
				onReceive((JData) messageJData.get(MESSAGE_TYPE_DATA)); //invio data to OnRece1ive
				
			} else {
				
				checkAck(messageJData); //ack elimino il pacchetto da quelli da inviare
				
			}
			
		}
		
	}
	
	
	//valida il messaggio
	private boolean validate(String message) {
		
		return true;
	}
	
	
	private JData getJDataMessage(String message) {
		
		JData messageJData = new JData();
		
		String temp = "";
		String temp2 = "";
		
		int nChar = 0;
		
		boolean value;
		
		
		message = message.substring(2);
		
		for(int i = 0; i < 2; i++) {
			
			temp = "";
		
		
			if (message.startsWith(MESSAGE_ID)) { //indicazione id 
				
				message = message.substring(MESSAGE_ID.length() + 2);
			
				for (int x = 0; message.charAt(x) != ','; x++) {
					temp += message.charAt(x);
				}
				
				message = message.substring(temp.length() + 2);
				
				messageJData.add(MESSAGE_ID, Long.parseLong(temp));
			}
			
			
			if (message.startsWith(MESSAGE_TYPE_ACK)) { //indicazione ack
				
				messageJData.add(MESSAGE_TYPE, MESSAGE_TYPE_ACK);
				
				
			}
			
			
			if (message.startsWith(MESSAGE_TYPE_DATA)) { //indicazione values
				
				messageJData.add(MESSAGE_TYPE, MESSAGE_TYPE_DATA);
				
				messageJData.add(MESSAGE_DATA, new JData());
				
				message = message.substring(MESSAGE_TYPE_DATA.length() + 5);
				
				//azzero le variabili prima di entrare nel ciclo
				value = false;
				temp = "";
				temp2 = "";
				
				for (int x = 0; message.charAt(x) != ']'; x++) { //scorro i caratteri
					
					nChar++; //serve per contare i carattri che elimenerò da message
					
					if (!value && message.charAt(x) != '"') { //value true caratteri chiave
						
						temp += message.charAt(x);
					
					} else if (message.charAt(x) == ':') {
					
						value = true;
						
					} else if (value) {
						
						temp2 += message.charAt(x);
					} else if (message.charAt(x) == ',' || message.charAt(x) == ']') { //store value nel JData
						
						if (temp2.charAt(0) == '"') { //stringa
							
							((JData) messageJData.get(MESSAGE_DATA)).add(temp, temp2.substring(1, temp2.length() - 1));
							
						} else if (temp2.contains(".")) { //double
							
							((JData) messageJData.get(MESSAGE_DATA)).add(temp, Double.parseDouble(temp2));
							
						} else if (temp2 == MESSAGE_BOOLEAN_TRUE || temp2 == MESSAGE_BOOLEAN_FALSE) { // boolean
							
							if (temp2 == MESSAGE_BOOLEAN_TRUE) {
								
								((JData) messageJData.get(MESSAGE_DATA)).add(temp, true);
								
							} else {
								
								((JData) messageJData.get(MESSAGE_DATA)).add(temp, false);
								
							}
							
						} else { //long/
							
							((JData) messageJData.get(MESSAGE_DATA)).add(temp, Long.parseLong(temp2));
						
						} //fine "switch" con stringhe
						
						//azzero i valori
						value = false;
						temp = "";
						temp2 = "";
						
					} //fine store nel db
					
				} //fine for
				
				if (i < 1) { //manca ancora id
					message = message.substring(nChar + 3);
					
				}
								
			} //fine values
		}
		
		
		
		return messageJData;
	}
	
	
	public void send(JData message) {
		
		long id = System.currentTimeMillis();
		
		String messageString = "{\"id\":" + id + ",\"values\":[{";
		
		for(int i = 0; i < message.size(); i++) {
			
			messageString += message.getKey(i) + ":";
			
			if (("" + message.getValue(i).getClass()) == "java.lang.Integer" ||
					("" + message.getValue(i).getClass()) == "java.lang.Double") {
			
				messageString += message.getValue(i);
			
			} else if (("" + message.getValue(i).getClass()) == "java.lang.Boolean") {
				
				if ((Boolean) message.getValue(i)) {
					
					messageString += MESSAGE_BOOLEAN_TRUE;
					
				} else {
					
					messageString += MESSAGE_BOOLEAN_FALSE;
					
				}
				
			} else if (("" + message.getValue(i).getClass()) == "java.lang.String") {
				
				messageString += "\"" + message.getValue(i) + "\"";
				
			}
			
			messageString += ",";
			
		}
		
		messageString = messageString.substring(0, messageString.length() -1);
		
		messageString += "}]}"; //messaggio in stringa creato
		
		
		
		sendMessageBuffer.put(id, messageString); //carico il mex nel buffer (sarà spedito automaticamente)
		
		
	}
	
	
	//verifico l'ack
	private void checkAck(JData message) {
		
		if (sendMessageBuffer.size() > 0) { //verifico che esistano messaggi in attesa di conferma
			
			if (sendMessageBuffer.containsKey(message.get(MESSAGE_ID))) { //verifico che l'id conetnuto ack esista
				
				sendMessageBuffer.remove(message.get(MESSAGE_ID)); //elimino il messaggio (CONFERMO)
			}
		}
 
	}
	
	//creo ack e lo invio
	private void sendAck(JData message) {
		
		String messageString = "{\"id\":" + message.get(MESSAGE_ID) + ",\"ack\":1}";
		
		sendMessageBuffer.put((Long) message.get(MESSAGE_ID), messageString); //carico il mex nel buffer (sarà spedito automaticamente)
			
	}
	
	
	abstract public void onReceive(JData message); //medoto da implementare e deve contere le istruzioni
												   //eseguire al ricevimento del messaggio

	
	//thread che continua a contattare il JTM e vedere se ci sono messaggi
	private class GetMessageThread extends Thread {
		
		public void run() {
			
			while(startThread) { //ciclo infinito perchè deve continuare finchè non stoppo il programma
			
				String message = mmJTM.receive();
			
				if (message.length() > 0) {
					execute(message);
				}
			}
		}
		
	}//fine thread
	
	
	//thread dedicato all'invio dei messaggi e a reinviare quelli non confermati entro lo scadere di un timer
	private class SendMessageThread extends Thread {
	
		public void run() { //ciclo infinito perchè deve continuare finchè non stoppo il programma
			//controllo di continuo il buffer dei messaggi da inviare e li invio se ce ne sono
			
			while (startThread) {
				
				//invio prima gli ack perchè possono scadere
				if (sendAckBuffer.size() > 0) {
					
					 for (long key :  sendAckBuffer.keySet())  {
						 
						 mmJTM.send("" + sendAckBuffer.get(key));
						 
						 sendAckBuffer.remove(key); //elimino ack dal buffer (basta inviarlo 1 volta sola)
						 
					 }
				
				}
				
				//invio messaggi dopo perchè non scadono
				if (sendMessageBuffer.size() > 0) {
					
					 for (long key :  sendMessageBuffer.keySet())  {
						 
						 if (sendMessageTimer.containsKey(key)) { //verifico la presenza della chiave nell'array del timer
							 if ((System.currentTimeMillis() - (Long) sendMessageTimer.get(key)) >= TIMER ) {
								 
								 mmJTM.send("" + sendMessageBuffer.get(key)); //invio il messaggio
								 
								 sendMessageTimer.remove(key); //elimino il vecchio valore del timer
								 sendMessageTimer.put(key, System.currentTimeMillis()); //setto il nuovo valore
							 }
						 } else { //non è ancora stato inviato il mex
							 
							 mmJTM.send("" + sendMessageBuffer.get(key)); //invio il messaggio
							 
							 sendMessageTimer.put(key, System.currentTimeMillis()); //setto il nuovo valore
							 
						 }
						 
						 
						 
					 }
				
				} //fine if sendMessageBuffer
				
			
			}
			
			
		}
		
	}//fine thread
	
	
	
	
}//fine classe
