package com.example.servicetest;

import java.util.HashMap;

import android.util.Log;

public abstract class Jack {
	
	private static final boolean DEBUG = true;
	
	private static final long TIMER = 1000; //tempo del timer in ms
	
	
	private static final String MESSAGE_TYPE = "message_type"; //campo dentro messageJackData che contine il tipo di mex
	//private static final String MESSAGE_DATA = "message_data"; //campo contente dati nel messaggio tipo dati 
	
	private static final String MESSAGE_ID = "id";
		
	private static final String MESSAGE_TYPE_ACK = "ack"; //messaggio ack per qualcosa inviato
	private static final String MESSAGE_TYPE_DATA = "values"; //messaggio normale contenente dati
		
	private static final String MESSAGE_BOOLEAN_TRUE = "t"; //simobolo true in booleano nel mex
	private static final String MESSAGE_BOOLEAN_FALSE = "f"; //simbolo false nel mex
	
	 
	
	private JTrasmissionMethod mmJTM; //contiene il metodo di trasmissione da usare e deve rispettare l'interfaccia
	
	
	private boolean startThread;
	
	private GetMessageThread getMessageThread; //thread get message
	
	private SendMessageThread sendMessageThread; //thread send message
	
	
	
	private HashMap<Long, String> sendMessageBuffer; //buffer per i mex da inviare
	private HashMap<Long, Long> sendMessageTimer; //buffer dei timer per i mex da inviare
	
	private HashMap<Long, String> sendAckBuffer; //buffer che contiene i mex ack da inviare (non necessitano di timer)
	
	
	public Jack(JTrasmissionMethod mmJTM) {
		
		this.mmJTM = mmJTM;
		
		startThread = false; //thread spenti
		
		
		sendMessageBuffer = new HashMap<Long, String>(); //buffer messaggi
		sendMessageTimer = new HashMap<Long, Long>(); //timer per invio messaggi
		
		sendAckBuffer = new HashMap<Long, String>(); //buffer ack
		
		 
		sendMessageThread = new SendMessageThread(); //thread invio messaggi
		
		
		getMessageThread = new GetMessageThread(); //creo thread per get message e lo avvio
		
	}
	
	public void start() { //start thread
		
		if (DEBUG) Log.d("Jack", "starting...");
		
		startThread = true; //imposto a true la variabile per iniziare il lavoro dei thread
		
		getMessageThread.start(); //inizio il thread per il polling di ricezione
		
		sendMessageThread.start(); //inizio il thread per il polling di invio
		
		if (DEBUG) Log.d("Jack", "Started");
	}
	
	public void stop() { //stop thread
		
		if (DEBUG) Log.d("Jack", "stopping...");
		
		startThread = false; //stoppo i thread
		
		if (DEBUG) Log.d("Jack", "Stopped");
	}
	
	private synchronized void execute(String message) { //corpo centrale della classe e decide cosa deve fare
		
		if (DEBUG) Log.d("Jack", "executing...");
		
		if (validate(message)) { //verifico che il messaggio ricevutio sia conforme al protocollo
			
			JData messageJData = getJDataMessage(message); 
			
			if (messageJData.get(MESSAGE_TYPE) == MESSAGE_TYPE_DATA) {
				
				sendAck(messageJData);
				
				if (DEBUG) Log.d("key", "" + messageJData.get("key")); 
				
				if (DEBUG) Log.d("Jack", "onReceive");
				
				onReceive(messageJData); //richiamo onReceive e passo l'oggetto messageJData che contiene le info del mex + il mex
				
			} else {
				
				checkAck(messageJData); //ack elimino il pacchetto da quelli da inviare
				
			} 
			
		}
		
		if (DEBUG) Log.d("Jack", "executed");
		
	}
	
	
	//valida il messaggio
	private boolean validate(String message) {
		
		if (DEBUG) Log.d("Jack", "validating...");
		
		if (DEBUG) Log.d("Jack", "validate");
		
		return true;
	}
	
	
	private JData getJDataMessage(String message) {
		
		if (DEBUG) Log.d("Jack", "getting Jdata from message...");
		
		JData messageJData = new JData();
		
		//this.messageJData = new JData();
		
		
		
		String temp = "";
		String temp2 = "";
		
		int nChar = 0;
		
		boolean value;
		
		
		message = message.substring(2); //elimino 2 caratteri iniziali
		
		for(int i = 0; i < 2; i++) {
			
			temp = "";
		
		
			if (message.startsWith(MESSAGE_ID)) { //indicazione id 
				
				message = message.substring(MESSAGE_ID.length() + 2); //elimino dal mex id + 2 caratteri (":)
			
				for (int x = 0; message.charAt(x) != ','; x++) { //prelevo l'id e lo memorizzo in temp
					temp += message.charAt(x);
				}
				
				message = message.substring(temp.length() + 2); //elimino dal mex la lunghezza dell'id + 2
				
				messageJData.add(MESSAGE_ID, Long.parseLong(temp)); //converto in long l'id
				
				if (DEBUG) Log.d("id", temp);
				
			} else if (message.startsWith(MESSAGE_TYPE_ACK)) { //indicazione ack  messaggio ack
				
				if (DEBUG) Log.d("message type", "ack");
				
				messageJData.add(MESSAGE_TYPE, MESSAGE_TYPE_ACK);
				
				if (i < 1) //sono al primo giro e manca ancora l'id
					message = message.substring(MESSAGE_TYPE_ACK.length() + 5); //elimino la lunghezza di ack + 5 caratteri
			} else if (message.startsWith(MESSAGE_TYPE_DATA)) { //indicazione values messaggio contenente dati
				
				if (DEBUG) Log.d("message type", "data");
				
				messageJData.add(MESSAGE_TYPE, MESSAGE_TYPE_DATA);
				
				message = message.substring(MESSAGE_TYPE_DATA.length() + 5);
				
				//azzero le variabili prima di entrare nel ciclo
				value = false;
				temp = ""; 
				temp2 = "";
				nChar = 0;
				
				for (int x = 0; message.charAt(x) != '}'; x++) { //scorro i caratteri di message
					
					nChar++; //serve per contare i carattri che elimenerò da message
					
					if (message.charAt(x) == ',' || message.charAt(x) == ']') { //store value nel JData						
											
						if (temp2.charAt(0) == '"') { //stringa
							
							messageJData.add(temp, temp2.substring(1, temp2.length() - 1));
							
						} else if (temp2.contains(".")) { //double
							
							messageJData.add(temp, Double.parseDouble(temp2));
							
						} else if (temp2 == MESSAGE_BOOLEAN_TRUE || temp2 == MESSAGE_BOOLEAN_FALSE) { // boolean
							
							if (temp2 == MESSAGE_BOOLEAN_TRUE) { //true
								
								messageJData.add(temp, true);
								
							} else { //false
								
								messageJData.add(temp, false);
								
							}
							
						} else { //long
							
							messageJData.add(temp, Long.parseLong(temp2));
						
						} //fine switch tipi
						
						
						if (DEBUG) Log.d(temp, "" + messageJData.get(temp)); //stampo dal JData
						
						//azzero i valori
						value = false;
						temp = "";
						temp2 = "";
						 
					} else if (message.charAt(x) == ':') { //passo da caratteri della chiave a caratteri del valore
						
						value = true;
						
					} else if (!value && message.charAt(x) != '"') { //value = true caratteri CHIAVE
						
						temp += message.charAt(x);
						
						//if (DEBUG) Log.d("key", temp);
					
						
					} else if (value) { //caratteri del VALORE value = false
						
						temp2 += message.charAt(x);
						
						//if (DEBUG) Log.d("value", temp2);
						
					}
					
				} //fine for values 
				
				
				//Log.e("Jack", "" + i);
				
				
				if (i < 1) //manca ancora id
					message = message.substring(nChar + 3);
					 
								
			} //fine values
			
			
		}
		
		if (DEBUG) Log.d("Jack", "JData getted");
		
		return messageJData;
	}
	
	
	public void send(JData message) {
		
		if (DEBUG) Log.d("Jack", "creating message to send...");
		
		
		long id = System.currentTimeMillis(); //id = timestamp
		
		String messageString = "{\"id\":" + id + ",\"values\":[{"; //intenstazione id + values
		
		
		for(int i = 0; i < message.size(); i++) {
			
			messageString += message.getKey(i) + ":";
			
					
			
			if (message.getValue(i) instanceof Integer) { //type integer
			
				messageString += ((Integer) message.getValue(i)).toString();
				
			} else if (message.getValue(i) instanceof Double) { //type double
			
				messageString += ((Double) message.getValue(i)).toString();
			
			} else if (message.getValue(i) instanceof Boolean) { //boolean traducon i valori impostati
				
				if ((Boolean) message.getValue(i)) {
					
					messageString += MESSAGE_BOOLEAN_TRUE;
					
				} else {
					
					messageString += MESSAGE_BOOLEAN_FALSE;
					
				}
				
			} else if (message.getValue(i) instanceof String) { //stringa aggiungo "" inzio e fine
				
				messageString += "\"" + ((String) message.getValue(i)).toString() + "\"";
				
				
			} /*else { //nessun tipo predefinito
				
				messageString += message.getValue(i).toString();
			}*/
			
			messageString += ","; //metto la virgola per separaere i valori
			
		}
		
		
		messageString = messageString.substring(0, messageString.length() -1); //elimino l'ultima virgola
		
		messageString += "}]}"; //messaggio in stringa creato
		
	
		
		
		sendMessageBuffer.put(id, messageString); //carico il mex nel buffer (sarà spedito automaticamente)
		
		if (DEBUG) Log.d("Jack", "message put in buffer");
		
		
	}
	
	
	//verifico l'ack
	private void checkAck(JData message) {
		
		if (DEBUG) Log.d("Jack", "checking ack...");
		
		if (sendMessageBuffer.size() > 0) { //verifico che esistano messaggi in attesa di conferma
			
			if (sendMessageBuffer.containsKey(message.get(MESSAGE_ID))) { //verifico che l'id conetnuto ack esista
				
				sendMessageBuffer.remove(message.get(MESSAGE_ID)); //elimino il messaggio (CONFERMO)
				
				if (DEBUG) Log.d("Jack", "message confirmed...");
			}
		}
		
		
 
	}
	
	//creo ack e lo invio
	private void sendAck(JData message) { //invio ack
		
		String messageString = "{\"id\":" + message.get(MESSAGE_ID) + ",\"ack\":1}";
		
		sendAckBuffer.put((Long) message.get(MESSAGE_ID), messageString); //carico il mex nel buffer (sarà spedito automaticamente)
			
	}
	
	
	abstract public void onReceive(JData message); //medoto da implementare e deve contere le istruzioni
												   //eseguire al ricevimento del messaggio

	
	//thread che continua a contattare il JTM e vedere se ci sono messaggi
	private class GetMessageThread extends Thread {
		
		public void run() {
			
			if (DEBUG) Log.d("Jack", "run polling receive");
			
			while (true) { //ciclo infinito perchè deve continuare finchè non stoppo il programma
				
				while (startThread) { 
			
					String message = mmJTM.receive();
			
					if (message.length() > 0) {
						execute(message);
					}
				}
			}
		}
		
	}//fine thread
	
	
	//thread dedicato all'invio dei messaggi e a reinviare quelli non confermati entro lo scadere di un timer
	private class SendMessageThread extends Thread {
	
		public void run() { //ciclo infinito perchè deve continuare finchè non stoppo il programma
			//controllo di continuo il buffer dei messaggi da inviare e li invio se ce ne sono
			
			if (DEBUG) Log.d("Jack", "run polling send");
			
			while (true) {
			
				while (startThread) {
				
					//invio prima gli ack perchè possono scadere
					if (sendAckBuffer.size() > 0) {
					
						for (long key :  sendAckBuffer.keySet())  {
						 
							mmJTM.send("" + sendAckBuffer.get(key));
						 
							sendAckBuffer.remove(key); //elimino ack dal buffer (basta inviarlo 1 volta sola)
							
							//boolean t = sendAckBuffer.containsKey(key);
							
							//Log.e("Jack", "" + t);
						 
						}
				
					}
				
					//invio messaggi dopo perchè non scadono
					if (sendMessageBuffer.size() > 0) {
					
						for (long key :  sendMessageBuffer.keySet())  {
						 
							if (sendMessageTimer.containsKey(key)) { //verifico la presenza della chiave nell'array del timer
								if ((System.currentTimeMillis() - (Long) sendMessageTimer.get(key)) >= TIMER ) {
								 
									mmJTM.send("" + sendMessageBuffer.get(key)); //invio il messaggio
								 
									sendMessageTimer.remove(key); //elimino il vecchio valore del timer
									sendMessageTimer.put(key, System.currentTimeMillis()); //setto il nuovo valore
								}
							} else { //non è ancora stato inviato il mex
							 
								mmJTM.send("" + sendMessageBuffer.get(key)); //invio il messaggio
							 
								sendMessageTimer.put(key, System.currentTimeMillis()); //setto il nuovo valore
							 
							}
						 
						 
						 
						}
				
					} //fine if sendMessageBuffer
				
			
				}
				
			}//fine ciclo infinito
			
			
		}
		
	}//fine thread
	
	
	
	
}//fine classe
